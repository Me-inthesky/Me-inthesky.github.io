<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BFC与IFC</title>
    <url>/2021/10/10/BFC(%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87)/</url>
    <content><![CDATA[<h1 id="BFC-块级格式化上下文"><a href="#BFC-块级格式化上下文" class="headerlink" title="BFC(块级格式化上下文)"></a>BFC(块级格式化上下文)</h1><h2 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h2><ul>
<li>盒子是从包含块顶部开始一个挨着一个布局的，盒子垂直方向的距离由margin决定，<strong>属于同一个BFC的两个相邻Box的上下margin会发生重叠</strong>；</li>
<li>水平方向上，每个盒子的左边缘都会接触包含块的左边缘（从右向左的格式则相反）</li>
<li>BFC的区域不会与float重叠；</li>
<li><strong>BFC就是页面上的一个隔离的独立容器</strong>，容器里面的子元素不会影响到外面的元素。反之也如此；</li>
<li>计算BFC的高度时，浮动元素也参与计算；</li>
</ul>
<h2 id="2-产生条件"><a href="#2-产生条件" class="headerlink" title="2.产生条件"></a>2.产生条件</h2><ul>
<li>float的属性不为none；</li>
<li>position为absolute或fixed；</li>
<li>display为inline-block。table-cell，table-caption，flex；</li>
<li>overflow不为visible(overflow默认值是visible)</li>
<li>根元素&lt;html&gt;</li>
</ul>
<h1 id="IFC-行内格式化上下文"><a href="#IFC-行内格式化上下文" class="headerlink" title="IFC(行内格式化上下文)"></a>IFC(行内格式化上下文)</h1><h2 id="1-行框"><a href="#1-行框" class="headerlink" title="1.行框"></a>1.行框</h2><p>IFC内联元素对齐完之后形成的四方块儿区域，叫做一个line box(行框)。行框不是内联元素的父元素</p>
<p>宽度：由包含它的元素的宽度和包含它的元素里面有没有float元素来决定（其实就是父元素的宽）</p>
<p>高度：由内部元素中实际高度最高的元素而计算出来。</p>
<h2 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h2><ul>
<li><p>高度计算：由line-height决定(line-height是vertical-align参考的边界值)</p>
</li>
<li><p>水平排列，margin，padding，border可以设置，但垂直方向上不算入高度。但无法设置width和height</p>
</li>
<li><p>垂直居中：当父元素没有设置高度时，内部所有元素(内联元素)设置verticle-align:middle后，将会居中对齐</p>
<p>​                    当设置了父元素高度后，内联元素居中对齐，但整体没有在父元素中居中。整体设置line-height=父元素height后(此时IFC高度等于父元素高度)才会在父元素上居中对齐</p>
<p>​                    (某个内联元素的高&lt;行框高，垂直方向上的位置由verticle-align决定)</p>
</li>
<li><p>水平居中：设置父元素为text-align：center；</p>
<p>(行框的宽&gt;行框中内联元素的宽，水平方向上的位置由text-align决定)</p>
</li>
</ul>
<h2 id="3-产生条件"><a href="#3-产生条件" class="headerlink" title="3.产生条件"></a>3.产生条件</h2><ul>
<li>font-size</li>
<li>line-height</li>
<li>height</li>
<li>verticle-align</li>
<li>display：inline-block和line</li>
</ul>
<h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><p>参考地址：<a href="https://www.cnblogs.com/lauzhishuai/p/10953608.html">https://www.cnblogs.com/lauzhishuai/p/10953608.html</a></p>
<h2 id="1-为什么要清除浮动"><a href="#1-为什么要清除浮动" class="headerlink" title="1.为什么要清除浮动"></a>1.为什么要清除浮动</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;topDiv&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;floatDiv&quot;</span>&gt;</span>float left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;textDiv&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bottomDiv&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20211010222612549.png" alt="image-20211010222612549"></p>
<p>上图为不清除浮动所造成的问题：</p>
<ol>
<li>由于.textDiv两旁存在浮动，蓝色文字围绕浮动元素排列，但我们可能希望文字在下方单独排列。</li>
<li>浮动元素超出父元素的高度，并没有撑开父元素，若没有.textDiv，则父元素的高度将会为0。</li>
<li>浮动元素影响了父元素的兄弟元素(黑色文本)的排版。</li>
</ol>
<h2 id="2-清除浮动的方法"><a href="#2-清除浮动的方法" class="headerlink" title="2.清除浮动的方法"></a>2.清除浮动的方法</h2><h3 id="2-1-利用clear"><a href="#2-1-利用clear" class="headerlink" title="2.1 利用clear"></a>2.1 利用clear</h3><p>给需要清除浮动的元素添加如下样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.textDiv</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid blue;</span><br><span class="line">    <span class="attribute">clear</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>缺点：如果产生浮动的元素在文本后面，则此方法不行，就算用了clear:right也不行。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;topDiv&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;textDiv&quot;</span>&gt;</span>..........<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;floatDiv&quot;</span>&gt;</span>float left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bottomDiv&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以用如下方法</p>
<h3 id="2-2-添加空白块级元素"><a href="#2-2-添加空白块级元素" class="headerlink" title="2.2 添加空白块级元素"></a>2.2 添加空白块级元素</h3><p>在父级元素末尾插入一个没有内容的<strong>块级元素</strong>(一定要是块级元素)div，并清除周边浮动</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;topDiv&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;textDiv&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;floatDiv&quot;</span>&gt;</span>float left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;blankDiv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bottomDiv&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.blankDiv</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-利用伪元素"><a href="#2-3-利用伪元素" class="headerlink" title="2.3 利用伪元素"></a>2.3 利用伪元素</h3><p>在父元素上添加一个类(如下)，通过伪元素在需要清除浮动的元素的父元素末尾添加一个块来清除浮动。(原理同2.2)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">    content: <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-利用BFC"><a href="#2-4-利用BFC" class="headerlink" title="2.4 利用BFC"></a>2.4 利用BFC</h3><p>将需要清除浮动的元素的父元素设置为BFC，BFC的一条特性为：计算BFC的高度时，浮动元素也参与计算。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.topDiv</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid black;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">overflow</span>: auto; //此时产生BFC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>循环遍历加监听的问题</title>
    <url>/2021/10/11/%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E5%8A%A0%E7%9B%91%E5%90%AC/</url>
    <content><![CDATA[<h2 id="1-用var失败的原因"><a href="#1-用var失败的原因" class="headerlink" title="1 用var失败的原因"></a>1 用var失败的原因</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btns = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;btns.length;i++)&#123;</span><br><span class="line">            btns[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                alert(i);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>点击监听事件是异步执行的，当点击按钮执行相应函数之前，同步任务(循环)已经执行结束，此时在全局作用域下的 i 已经为固定值。执行alert(i)时，沿着作用域链找到全局作用域下的 i ，导致点击每个按钮得到的结果相同。</li>
</ul>
<h2 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2 解决方法"></a>2 解决方法</h2><h3 id="2-1-添加属性"><a href="#2-1-添加属性" class="headerlink" title="2.1 添加属性"></a>2.1 添加属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;btns.length;i++)&#123;</span><br><span class="line">            btns[i].index = i;</span><br><span class="line">            btns[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                alert(<span class="built_in">this</span>.index);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>原理：给每一个按钮绑定一个单独的属性，之后在执行点击监听的异步任务时，通过自己的属性来访问该值，不去访问全局作用域下的 i</p>
<h3 id="2-2-立即执行函数"><a href="#2-2-立即执行函数" class="headerlink" title="2.2 立即执行函数"></a>2.2 立即执行函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btns = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;btns.length;i++)&#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">            btns[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                alert(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>原理：将每次执行for循环的 i 当作实参传入函数，在外部function函数中的 i 是局部变量，所以每次添加监听的 i 是不同的。由于闭包的原理，i 会一直存在，在执行点击的异步任务时可以访问到每个作用域下的 i</p>
<h3 id="2-3-用let替换var"><a href="#2-3-用let替换var" class="headerlink" title="2.3 用let替换var"></a>2.3 用let替换var</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btns = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;btns.length;i++)&#123;</span><br><span class="line">           btns[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">               alert(i);</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>原理：let发挥效果在块级作用域，每个for循环下的代码都在相互独立的块级作用域下，在执行点击监听函数时，内部function的 i 顺着作用域链不会找到全局作用域去，而是在块级作用域找到每个独立的 i</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2021/10/13/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="1-什么时闭包"><a href="#1-什么时闭包" class="headerlink" title="1. 什么时闭包"></a>1. 什么时闭包</h2><p>闭包就是将函数内部和函数外部连接起来的一座桥梁。<strong>闭包就是能够读取其他函数内部变量的函数</strong></p>
<h2 id="2-闭包的产生与死亡"><a href="#2-闭包的产生与死亡" class="headerlink" title="2. 闭包的产生与死亡"></a>2. 闭包的产生与死亡</h2><ul>
<li>产生：当一个嵌套的内部(子)函数引用了外部(父)函数的变量(函数)时，产生闭包</li>
<li>死亡：内部函数成为垃圾对象时</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">2</span> <span class="comment">//内部函数不需要调用，闭包此时产生</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        a++ </span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f=fn1() <span class="comment">//此时f一直指向fn2，闭包一直存在</span></span><br><span class="line">f() <span class="comment">//输出3</span></span><br><span class="line">f() <span class="comment">//输出4</span></span><br><span class="line">f=<span class="literal">null</span> <span class="comment">//fn2成为垃圾对象，闭包消失</span></span><br></pre></td></tr></table></figure>

<h2 id="3-作用"><a href="#3-作用" class="headerlink" title="3. 作用"></a>3. 作用</h2><ol>
<li>使用函数内部的变量在函数执行完成后，仍然存活在内存中。(延长了局部变量的生命周期)</li>
<li>让函数外部可以操作和读写函数内部的变量和函数。</li>
</ol>
<h2 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h2><ul>
<li>函数执行完成后，内部的局部变量没有被释放，占用内存，同时占用时间变长。(可以通过fn=null，将fn2变为垃圾对象)</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>获取异步操作的数据</title>
    <url>/2021/10/14/%E5%A4%96%E9%83%A8%E8%AF%BB%E5%8F%96%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="获取异步操作的数据"><a href="#获取异步操作的数据" class="headerlink" title="获取异步操作的数据"></a>获取异步操作的数据</h1><h2 id="1-错误方法"><a href="#1-错误方法" class="headerlink" title="1. 错误方法"></a>1. 错误方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name=<span class="string">&#x27;yzy&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> name <span class="comment">//  位置1</span></span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> name  <span class="comment">//  位置2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getData())</span><br></pre></td></tr></table></figure>

<p><strong>当执行函数getData时，setTimeout为异步任务，此时函数中无法立即执行setTimeout函数</strong></p>
<ul>
<li>如果在位置1返回，此时函数体内部没有任何语句，最后将在控制台输出undefined</li>
<li>如果在位置2返回，此时函数体内部只有return name，由于name没有定义，最后将会报错</li>
</ul>
<h2 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2. 解决方法"></a>2. 解决方法</h2><h3 id="2-1-用回调函数"><a href="#2-1-用回调函数" class="headerlink" title="2.1 用回调函数"></a>2.1 用回调函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name=<span class="string">&#x27;yzy&#x27;</span>;</span><br><span class="line">        callback(name)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData(<span class="function"><span class="keyword">function</span>(<span class="params">aaa</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(aaa) <span class="comment">//1s后输出yzy</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-用Promise-then的方法"><a href="#2-2-用Promise-then的方法" class="headerlink" title="2.2 用Promise.then的方法"></a>2.2 用Promise.then的方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;yzy&#x27;</span></span><br><span class="line">    resolve(name)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(getData)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-3-用async、await方法"><a href="#2-3-用async、await方法" class="headerlink" title="2.3 用async、await方法"></a>2.3 用async、await方法</h3><ul>
<li>async修饰的函数，返回值会以Promise对象的形式返回</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test()) <span class="comment">//返回值为  Promise &#123;&#x27;aaaa&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在async修饰的函数中，通过await，得到的async修饰的函数的返回值将不会是Promise对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data=<span class="keyword">await</span> test()</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">//返回值为 &#x27;aaaa&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上所述：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> name = <span class="string">&#x27;yzy&#x27;</span></span><br><span class="line">      resolve(name)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">await</span> test()</span><br><span class="line">  <span class="built_in">console</span>.log(data) <span class="comment">//返回值为 &#x27;aaaa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型、转换、运算</title>
    <url>/2021/10/15/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="数据类型、转换、运算"><a href="#数据类型、转换、运算" class="headerlink" title="数据类型、转换、运算"></a>数据类型、转换、运算</h1><h2 id="1-数据类型与存储"><a href="#1-数据类型与存储" class="headerlink" title="1 数据类型与存储"></a>1 数据类型与存储</h2><h3 id="1-1-数据类型"><a href="#1-1-数据类型" class="headerlink" title="1.1 数据类型"></a>1.1 数据类型</h3><ol>
<li><p>基本数据类型</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null：定义并赋值，但值未null</li>
<li>undefine：定义了但未赋值</li>
</ul>
</li>
<li><p>引用数据类型</p>
<ul>
<li>object</li>
</ul>
<!--NaN表示非数字（但是typeof NaN返回number） NaN不与任何值相等，包括自己，可用isNaN()检查一个值是否为NaN--></li>
</ol>
<h3 id="1-2-存储方式"><a href="#1-2-存储方式" class="headerlink" title="1.2 存储方式"></a>1.2 存储方式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>当xxx为基本数据类型，a保存的就是xxx</li>
<li>当xxx为引用数据类型(对象)，a保存的是地址值</li>
<li>当xxx为变量，看变量是基本数据类型还是对象<ul>
<li><strong>当变量保存的是基本数据类型，则拷贝一份数据存到a</strong></li>
<li><strong>当变量保存的是引用数据类型，则a与xxx保存相同地址值，并指向同一内存空间</strong></li>
</ul>
</li>
</ul>
<h2 id="2-数据类型转换"><a href="#2-数据类型转换" class="headerlink" title="2 数据类型转换"></a>2 数据类型转换</h2><h3 id="2-1-typeof"><a href="#2-1-typeof" class="headerlink" title="2.1 typeof"></a>2.1 typeof</h3><ol>
<li>检查数据的类型并通过<strong>字符串的形式</strong>返回</li>
<li>若检查值为null，返回值为object</li>
<li>若检查的数字值大于上限，返回infinity</li>
<li>若检测值为NaN，返回number</li>
<li>若检测值未声明或者声明了未初始化，返回都是undefined</li>
</ol>
<h3 id="2-2-数据转换"><a href="#2-2-数据转换" class="headerlink" title="2.2 数据转换"></a>2.2 数据转换</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">string</th>
<th align="center">number</th>
<th align="center">boolean</th>
<th align="center">null</th>
<th align="center">undefined</th>
<th align="center">object</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.toString()</td>
<td align="center">-</td>
<td align="center">string</td>
<td align="center">string</td>
<td align="center">报错</td>
<td align="center">报错</td>
<td align="center">string</td>
</tr>
<tr>
<td align="center">String()</td>
<td align="center">-</td>
<td align="center">string</td>
<td align="center">string</td>
<td align="center">‘null’</td>
<td align="center">‘undefined’</td>
<td align="center">string</td>
</tr>
<tr>
<td align="center">Number()</td>
<td align="center"><strong>NaN(字符串中为非数字时)</strong></td>
<td align="center">-</td>
<td align="center">1或0</td>
<td align="center">0</td>
<td align="center">NaN</td>
<td align="center">NaN</td>
</tr>
<tr>
<td align="center">parseInt</td>
<td align="center">有效整数/NaN</td>
<td align="center">有效整数</td>
<td align="center">NaN</td>
<td align="center">NaN</td>
<td align="center">NaN</td>
<td align="center">NaN</td>
</tr>
<tr>
<td align="center">parseFloat</td>
<td align="center">有效小数/NaN</td>
<td align="center">有效小数</td>
<td align="center">NaN</td>
<td align="center">NaN</td>
<td align="center">NaN</td>
<td align="center">NaN</td>
</tr>
<tr>
<td align="center">Boolean()</td>
<td align="center"><strong>true(除了空串)</strong></td>
<td align="center"><strong>true(除0和NaN)</strong></td>
<td align="center">-</td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">true</td>
</tr>
</tbody></table>
<h2 id="3-数据类型的运算"><a href="#3-数据类型的运算" class="headerlink" title="3 数据类型的运算"></a>3 数据类型的运算</h2><h3 id="3-1-与字符串相加"><a href="#3-1-与字符串相加" class="headerlink" title="3.1 与字符串相加"></a>3.1 与字符串相加</h3><ul>
<li>任何值与字符串相加<strong>先要转换为字符串</strong>再加</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> val=<span class="number">555</span></span><br><span class="line"><span class="built_in">console</span>.log(val+<span class="string">&#x27;字符串&#x27;</span>)</span><br><span class="line"><span class="comment">// 最终显示：555字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：一元操作符++、--与+、-的计算法则不同</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;a&#x27;</span></span><br><span class="line">str++;</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br><span class="line"><span class="comment">// 最终显示NaN，详细查看4.3</span></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> val=<span class="number">555</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;字符串&#x27;</span>+val)</span><br></pre></td></tr></table></figure>

<p>最终显示：字符串555</p>
<h3 id="3-2-隐式转换"><a href="#3-2-隐式转换" class="headerlink" title="3.2 隐式转换"></a>3.2 隐式转换</h3><ol>
<li><p>可通过+’’的方式将值转换为string</p>
<p>12 + ‘’ = ‘12’</p>
</li>
<li><p>可通过-0等作number的隐式转换</p>
</li>
</ol>
<h2 id="4-运算"><a href="#4-运算" class="headerlink" title="4 运算"></a>4 运算</h2><h3 id="4-1-与运算、或运算-逻辑运算"><a href="#4-1-与运算、或运算-逻辑运算" class="headerlink" title="4.1 与运算、或运算(逻辑运算)"></a>4.1 与运算、或运算(逻辑运算)</h3><ul>
<li><p>与运算：表达式1&amp;&amp;表达式2</p>
<p>若表达式1的值为true，则<strong>返回第二个值</strong></p>
<p>若表达式1的值为false，则<strong>返回第一个值</strong></p>
</li>
<li><p>或运算：表达式1||表达式2</p>
<p>若表达式1的值为true，则<strong>返回第一个值</strong></p>
<p>若表达式1的值为false，则<strong>返回第二个值</strong></p>
</li>
</ul>
<h3 id="4-2-关系运算"><a href="#4-2-关系运算" class="headerlink" title="4.2 关系运算"></a>4.2 关系运算</h3><ul>
<li><p>任何值与NaN比较返回值都是false</p>
</li>
<li><p>若<strong>单侧</strong>为字符串型数字(如’1’、’123’)，比较时会转换为number型在比较</p>
</li>
<li><p>若两侧均为字符串，则不会转换，直接比较unicode编码</p>
</li>
<li><p>全等运算符：===</p>
<p>运算时不会做类型转换，类型不同就会返回false</p>
<p>null==undefined返回true</p>
<p>null===undefined返回false</p>
</li>
</ul>
<h3 id="4-3-一元运算符-、–"><a href="#4-3-一元运算符-、–" class="headerlink" title="4.3 一元运算符++、–"></a>4.3 一元运算符++、–</h3><ul>
<li>当参与运算的变量为String类型时</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str1=<span class="string">&#x27;a&#x27;</span> <span class="comment">//字符为非数字</span></span><br><span class="line">str++;</span><br><span class="line"><span class="built_in">console</span>.log(str1) <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1=<span class="string">&#x27;1&#x27;</span> <span class="comment">//字符为数字</span></span><br><span class="line">str++;</span><br><span class="line"><span class="built_in">console</span>.log(str1) <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str2=<span class="string">&#x27;a&#x27;</span></span><br><span class="line">str2+=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str2) <span class="comment">//a1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>变量声明、作用域、执行上下文</title>
    <url>/2021/10/16/%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="函数、变量、作用域"><a href="#函数、变量、作用域" class="headerlink" title="函数、变量、作用域"></a>函数、变量、作用域</h1><h2 id="1-var、let、const"><a href="#1-var、let、const" class="headerlink" title="1 var、let、const"></a>1 var、let、const</h2><table>
<thead>
<tr>
<th align="center"></th>
<th>声明范围</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">var</td>
<td>块作用域</td>
<td><strong>声明提升</strong></td>
</tr>
<tr>
<td align="center">let</td>
<td>函数作用域</td>
<td>声明的变量<strong>不允许重复声明</strong>(只是不允许重复声明，但是可以更改)</td>
</tr>
<tr>
<td align="center">const</td>
<td>函数作用域</td>
<td>声明时<strong>必须初始化</strong>，且后续不能更改</td>
</tr>
</tbody></table>
<ul>
<li> 省略var操作符</li>
</ul>
<p>在函数内定义变量时，省略var操作符后，可以创建一个全局变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  message1 = <span class="string">&#x27;全局变量&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> message2 = <span class="string">&#x27;局部变量&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">test() <span class="comment">// 此时执行函数，创建message1和message2，但执行结束后message2会被销毁</span></span><br><span class="line"><span class="built_in">console</span>.log(message1) <span class="comment">//正确</span></span><br><span class="line"><span class="built_in">console</span>.log(message2) <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<h2 id="2-声明提升"><a href="#2-声明提升" class="headerlink" title="2 声明提升"></a>2 声明提升</h2><h3 id="2-1-变量声明提升"><a href="#2-1-变量声明提升" class="headerlink" title="2.1 变量声明提升"></a>2.1 变量声明提升</h3><p>通过<strong>var声明变量</strong>时，会自动提升到函数作用域顶部</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(age)</span><br><span class="line"><span class="keyword">var</span> age=<span class="number">20</span></span><br><span class="line"><span class="comment">// 运行时等价于</span></span><br><span class="line"><span class="keyword">var</span> age</span><br><span class="line"><span class="built_in">console</span>.log(age) <span class="comment">//undefined</span></span><br><span class="line">age=<span class="number">20</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-函数声明提升"><a href="#2-2-函数声明提升" class="headerlink" title="2.2 函数声明提升"></a>2.2 函数声明提升</h3><p>在执行代码时，在函数定义之前就可以调用函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fun()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;函数声明提升&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时函数仍可以正常调用</span></span><br></pre></td></tr></table></figure>

<ul>
<li>优先级：先函数提升，再变量提升</li>
</ul>
<p>示例一：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br><span class="line">c(<span class="number">2</span>) <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c</span><br><span class="line">c=<span class="number">1</span> </span><br><span class="line">c(<span class="number">2</span>) <span class="comment">//此时的c是一个变量，所有报错</span></span><br></pre></td></tr></table></figure>

<p>示例二：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn1() <span class="comment">//可调用  函数提升</span></span><br><span class="line">fn2() <span class="comment">//不可调用  变量提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">var</span> fn2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a>3 函数</h2><p>可执行的对象</p>
<h3 id="3-1-回调函数"><a href="#3-1-回调函数" class="headerlink" title="3.1 回调函数"></a>3.1 回调函数</h3><p>自定义的非直接调用但最后执行了的函数</p>
<h3 id="3-2-立即执行函数"><a href="#3-2-立即执行函数" class="headerlink" title="3.2 立即执行函数"></a>3.2 立即执行函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	.....</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>作用：1.隐藏实现：直接执行，外部看不见(给window加属性)</p>
<p>​            2.不会污染外部(全局)命名空间</p>
<h2 id="4-作用域、执行上下文"><a href="#4-作用域、执行上下文" class="headerlink" title="4 作用域、执行上下文"></a>4 作用域、执行上下文</h2><h3 id="4-1-全局执行上下文"><a href="#4-1-全局执行上下文" class="headerlink" title="4.1 全局执行上下文"></a>4.1 全局执行上下文</h3><p>执行流程：</p>
<ol>
<li><p>在执行全局代码前将window确定为全局执行上下文</p>
</li>
<li><p>对全局数据<strong>进行预处理</strong></p>
<p>(1) var定义的全局变量(只是定义，但未赋值，为undefined),添加为window的属性</p>
<p>(2) function声明的全局函数，添加为window的方法</p>
<p>(3) this赋值为window</p>
</li>
</ol>
<h3 id="4-2-函数执行上下文"><a href="#4-2-函数执行上下文" class="headerlink" title="4.2 函数执行上下文"></a>4.2 函数执行上下文</h3><p>执行流程：</p>
<ol>
<li><p>调用函数，准备执行函数体之前，创建对应的函数执行上下文对象</p>
</li>
<li><p>对局部数据<strong>进行预处理</strong></p>
<p>(1) 形参变量，添加为执行上下文的属性</p>
<p>(2) arguments，添加为执行上下文的属性</p>
<p>(3) var定义为局部变量(只是定义，但未赋值)，添加为执行上下文的属性</p>
<p>(4) function声明的全局函数，添加为window的方法</p>
<p>(5) this</p>
</li>
<li><p>执行函数体代码</p>
</li>
</ol>
<h3 id="4-3-作用域与执行上下文的区别"><a href="#4-3-作用域与执行上下文的区别" class="headerlink" title="4.3 作用域与执行上下文的区别"></a>4.3 作用域与执行上下文的区别</h3><p>区别：</p>
<p>​    1.作用域在函数定义时就确定了，而不是调用时</p>
<pre><code>   执行上下文是在函数调用时创建
</code></pre>
<p>​    2.作用域为静态，定义后就一直存在，不会变动</p>
<p>​        执行上下文是调用时创建，函数执行结束就释放</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>js</tag>
      </tags>
  </entry>
</search>
